# Практические задания

В данном разделе вы найдете задания для практики, своеобразные этюды для
программистов, предназначенные для тренировки как навыком программирования, так
и навыков проведения исследовательской работы.

## Потоковый механизм ответа web-server на Cowboy

* Скачайте и установите `cowboy`  web-сервер, написанный на `erlang`.
  Реализуйте модуль HTTP ответа, который будет возвращать `200 OK` для HTTP
  `GET` запросов на страницу `http://localhost:8080/simple_response`.
  Используйте следующую
  [инструкцию](https://github.com/ninenines/cowboy/blob/master/doc/src/guide/getting_started.asciidoc)

* Дополнительно реализуйте модуль HTTP ответа, который будет возвращать `200
  OK` для HTTP `GET` запросов на страницу
  `http://localhost:8080/chunked_response` и выводить 10 chunk ответов типа
  `chunk #1`, `chunk #2`. Симулируйте работу каждого chunk функцией
  `timer:sleet(1000)`. Используйте следующий
  [пример](https://github.com/ninenines/cowboy/tree/master/examples/chunked_hello_world)
  для старта работы

* Дополнительно переработайте модуль HTTP ответа ``chunked_response``, чтобы
  отделить логику выполнения запроса от логики посылки ответа (функция для
  отправки chunks ``cowboy_req:stream_body`` не должна вызывать в коде, где
  осуществляется подготовка тела chunk ответа). Подсказка: напишите
  lambda-функцию, которая будет принимать и выполнять ленивую функцию для
  генерации каждого chunk. В качестве одного из значений, что возвращает эта
  функция - функция, которая выполняет генерацию следующего chunk.

## Немного о ленивых вычисления и процессах

Если Вы немного думали над вопросом, а в чем заключается особая польза в функции
склеивания ленивых списков, то могли заметить наверняка, что это очень удобный
механизм инкапсуляции потоков данных из разных источников - мы можем читать
часть данных из файлов, часть из БД, но с точки зрения клиентской функции этот
поток данных выглядит единообразно. Ничто не мешает нам соединять мощь
абстракции ленивых потоков с мощностью процессов и параллельных вычислений.
Задача из реальной жизни: есть некоторый поток, в котором большие блоки
последовательно читаются из файлов. Чтение из файла - операция достаточно
дорогая (по сравнению с памятью), а обработка данных из этого файла также может
оказаться дорогой. Если мы все делаем последовательно, сначала читаем один блок,
а затем его обрабатываем, то это может сказаться на производительности системы.
В таком случае, процессы нам помогут делать это параллельно.  Ленивый поток
данных нам предоставляет удобную абстракцию потока данных, а процессы нам
помогают выполнить чтение кусков данных из файла параллельно их обработке, то
есть, когда после обработки одного куска данных мы запросим следующий кусок - мы
его уже получим немедленно, так как он уже в памяти, а процесс время от времени
одчитывает нужные блоки. Реализуйте этот подход. При этом для клиентского кода
не должно быть разницы между обычным ленивым списком и списком с кешированием.
